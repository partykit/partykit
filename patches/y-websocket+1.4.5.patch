diff --git a/node_modules/y-websocket/bin/callback.js b/node_modules/y-websocket/bin/callback.js
index 4da8163..2bc33ff 100644
--- a/node_modules/y-websocket/bin/callback.js
+++ b/node_modules/y-websocket/bin/callback.js
@@ -1,4 +1,4 @@
-const http = require('http')
+
 
 const CALLBACK_URL = process.env.CALLBACK_URL ? new URL(process.env.CALLBACK_URL) : null
 const CALLBACK_TIMEOUT = process.env.CALLBACK_TIMEOUT || 5000
@@ -12,6 +12,7 @@ exports.isCallbackSet = !!CALLBACK_URL
  * @param {WSSharedDoc} doc
  */
 exports.callbackHandler = (update, origin, doc) => {
+  
   const room = doc.name
   const dataToSend = {
     room,
@@ -46,7 +47,7 @@ const callbackRequest = (url, timeout, data) => {
       'Content-Length': data.length
     }
   }
-  const req = http.request(options)
+  const req = require('http').request(options)
   req.on('timeout', () => {
     console.warn('Callback request timed out.')
     req.abort()
diff --git a/node_modules/y-websocket/bin/utils.js b/node_modules/y-websocket/bin/utils.js
index 311f905..b840d44 100644
--- a/node_modules/y-websocket/bin/utils.js
+++ b/node_modules/y-websocket/bin/utils.js
@@ -26,25 +26,26 @@ const persistenceDir = process.env.YPERSISTENCE
  * @type {{bindState: function(string,WSSharedDoc):void, writeState:function(string,WSSharedDoc):Promise<any>, provider: any}|null}
  */
 let persistence = null
-if (typeof persistenceDir === 'string') {
-  console.info('Persisting documents to "' + persistenceDir + '"')
-  // @ts-ignore
-  const LeveldbPersistence = require('y-leveldb').LeveldbPersistence
-  const ldb = new LeveldbPersistence(persistenceDir)
-  persistence = {
-    provider: ldb,
-    bindState: async (docName, ydoc) => {
-      const persistedYdoc = await ldb.getYDoc(docName)
-      const newUpdates = Y.encodeStateAsUpdate(ydoc)
-      ldb.storeUpdate(docName, newUpdates)
-      Y.applyUpdate(ydoc, Y.encodeStateAsUpdate(persistedYdoc))
-      ydoc.on('update', update => {
-        ldb.storeUpdate(docName, update)
-      })
-    },
-    writeState: async (docName, ydoc) => {}
-  }
-}
+// commenting out this section because it is not used
+// if (typeof persistenceDir === 'string') {
+//   console.info('Persisting documents to "' + persistenceDir + '"')
+//   // @ts-ignore
+//   const LeveldbPersistence = require('y-leveldb').LeveldbPersistence
+//   const ldb = new LeveldbPersistence(persistenceDir)
+//   persistence = {
+//     provider: ldb,
+//     bindState: async (docName, ydoc) => {
+//       const persistedYdoc = await ldb.getYDoc(docName)
+//       const newUpdates = Y.encodeStateAsUpdate(ydoc)
+//       ldb.storeUpdate(docName, newUpdates)
+//       Y.applyUpdate(ydoc, Y.encodeStateAsUpdate(persistedYdoc))
+//       ydoc.on('update', update => {
+//         ldb.storeUpdate(docName, update)
+//       })
+//     },
+//     writeState: async (docName, ydoc) => {}
+//   }
+// }
 
 /**
  * @param {{bindState: function(string,WSSharedDoc):void,
@@ -164,6 +165,8 @@ const messageListener = (conn, doc, message) => {
     const encoder = encoding.createEncoder()    
     const decoder = decoding.createDecoder(message)    
     const messageType = decoding.readVarUint(decoder)
+    
+    
     switch (messageType) {
       case messageSync:
         encoding.writeVarUint(encoder, messageSync)
@@ -208,7 +211,13 @@ const closeConn = (doc, conn) => {
       docs.delete(doc.name)
     }
   }
-  conn.close()
+  try{
+    conn.close()
+  }
+  catch(e){
+    console.error('closeConn error', e)
+  }
+  
 }
 
 /**
@@ -217,11 +226,11 @@ const closeConn = (doc, conn) => {
  * @param {Uint8Array} m
  */
 const send = (doc, conn, m) => {
-  if (conn.readyState !== wsReadyStateConnecting && conn.readyState !== wsReadyStateOpen) {
+  if (conn.readyState !== undefined && conn.readyState !== wsReadyStateConnecting && conn.readyState !== wsReadyStateOpen) {
     closeConn(doc, conn)
   }
   try {
-    conn.send(m, /** @param {any} err */ err => { err != null && closeConn(doc, conn) })
+    conn.send(m)
   } catch (e) {
     closeConn(doc, conn)
   }
@@ -235,12 +244,12 @@ const pingTimeout = 30000
  * @param {any} opts
  */
 exports.setupWSConnection = (conn, req, { docName = req.url.slice(1).split('?')[0], gc = true } = {}) => {
-  conn.binaryType = 'arraybuffer'
+  // conn.binaryType = 'arraybuffer'
   // get doc, initialize if it does not exist yet
   const doc = getYDoc(docName, gc)
   doc.conns.set(conn, new Set())
   // listen and reply to events
-  conn.on('message', /** @param {ArrayBuffer} message */ message => messageListener(conn, doc, new Uint8Array(message)))
+  conn.addEventListener('message', /** @param {ArrayBuffer} message */ message => typeof message.data !== 'string' && messageListener(conn, doc, new Uint8Array(message.data)))  
 
   // Check if connection is still alive
   let pongReceived = true
@@ -260,12 +269,14 @@ exports.setupWSConnection = (conn, req, { docName = req.url.slice(1).split('?')[
       }
     }
   }, pingTimeout)
-  conn.on('close', () => {
+  conn.addEventListener('close', () => {
     closeConn(doc, conn)
     clearInterval(pingInterval)
   })
-  conn.on('pong', () => {
-    pongReceived = true
+  conn.addEventListener('message', (message) => {
+    if(message.data === 'pong') {
+      pongReceived = true
+    }    
   })
   // put the following in a variables in a block so the interval handlers don't keep in in
   // scope
